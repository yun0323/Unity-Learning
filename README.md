# Unity-Learning

유니티 4월 7일
3D 오브젝트의 회전 기준은 
'축 그 자체'를 기준으로 회전함
오브젝트가 사람이라면 Y축은 머리 위를 향하는 화살표, X축은 오른쪽으로 향하는 Y축과 수직의 화살표, Z축은 시선의 정면 방향으로
향하는 화살표, 즉 이 각각의 화살표를 하나의 원통이라고 생각하고 이 각 원통들은  반 시계 방향이 +, 시계 방향이 -의 값을 가진다.

Time.deltaTime : 직전 프레임과 현재 프레임 사이의 시간 간격, 즉 현재 초당 프레임의 역수.

60fps라는 것은 1/60초가 60번 누적된 것,
즉 직전 프레임과 현재 프레임 사이의 시간 간격의 의미는 현 초당 프레임의 역수, 현 초당 프레임의 역수가 현 초당 프레임 수 만큼 누적되면 초당 프레임이 되기 때문.


4월 23일
이벤트 존에 들어와서 내 아바타가 텔레포트를 해야하는데 원하는 스탠딩 포인트에 텔레포트가 안되고 이벤트 트리거가 작동되던 시점의 포지션에 있는 상황

“프레임 간섭” (Frame Interference)
두 개 이상의 시스템이 같은 오브젝트에 영향을 주는데,
타이밍이 다르면 나중에 실행된 게 덮어써버리는 현상


async는 C#에서 **“비동기(Asynchronous) 실행”**을 위해 붙이는 메서드 키워드야.

쉽게 말해서:
“나 이거 천천히 할게~ 기다릴 수 있는 애니까,
중간에 한 템포 쉬거나 뭔가 기다려도 돼!” 라고 선언하는 거야.

Update()는 네가 “움직여!” 하는 지시고,
LateUpdate()는 **애니메이터가 “그럼 이렇게 바꿨어요”**라고 말하는 단계고,
Task.Yield()는 **“그거 다 끝나고 진짜 마지막에 할게요”**라는 타이밍임.


2025 4월 25일
CharacterController는
**“정확하게 제어되는 캐릭터용 충돌 + 이동 컨트롤러”**야.
Rigidbody 쓰면 튕기고 흔들리는데, 얘는 부드럽고 깔끔하게 움직임.

플레이어 텔레포트 후 원하는 스탠딩 포인트에 고정 시키려면 우선 카메라 이동후, 플레이어 인풋과 캐릭터 컨트롤러를 꺼지게 하고,
위치를 이동 시킨 코드를 적고 그다음 다시
캐릭터 컨트롤러를 키도록 작성하고, 스탠딩 포인트 Y좌표를 콜라이더가 있는 땅 위치와 정확히 발이 닿도록 구성하면 캐릭터가 지정한 자리로 이동하고, 공중이라고 인식안해서 텔포한 위치에서 휘적거리지도 않으며, 땅에 잘 붙어있기 때문에 위 아래로 진동하듯이 움직이지도 않는다.

4월 26일
기억 구조 프로토 타입, 인간과 같은 망각 구조->api 호출 시 전해지는 텍스트의 양 즉 기억 양은 동일 하되 무조건 기억해야 하는 이름이나 국적, 중요한 기억 내용은 필히 부조건 저장하고 나머지 전체 흐름 맥락은 가장 최근 대화 내용이 총용량에서 40프로 정도를 차지하게끔 자세하그 쓰이고 나머지 대화들은 지피티에게 알아서 요약 정리해서 대화 늘어날 수록 비중이 점점 줄어가도록 설계, 접접 압착되는 느낌->기억이 흐려지는 인간의 망각 기능, 혹은 특정 

4월 27일
Alt 누른 상태에서 rect transform에 스트레치클릭하면 다르게 보이고 다르게 적용됨 
스트레치에서 빨간색으로 설정해야 넓이 높이로 나옴 파란색으로 하면 오른쪽 왼쪽 이런 식으로 이상하게 나옴

5월 4일
Step Offset을 낮추면 캐릭터가 미세한 충돌면(땅, 경계면)을 턱으로 인식하지 않아서,
이상하게 올라가려다 끼이는 버그가 사라지는 것.

🧠 결론 정리
원인	설명
충돌 계산 순서 꼬임	CharacterController가 Collider보다 나중에 처리됨
Move 호출 안 됨	위치가 고정돼 있고, 충돌 정렬도 안 됨
Step Offset이나 Skin Width가 애매	Unity가 "이건 계단인가?" 헷갈림
값 살짝 바꾸면	Unity가 컴포넌트 재초기화함 → 정렬 재수행

✅ RPM 아바타의 발 위치가 기본 캐릭터보다 위에 있어서, GroundedOffset을 내려줘야 함
✅ 그렇게 해야 바닥을 제대로 감지하고 끼이는 물리 버그가 사라짐

코드	의미
other.transform	부딪힌 오브젝트의 Transform
avatar = other.transform;	플레이어의 Transform을 avatar라는 이름으로 저장
이후 사용	위치 순간이동, 회전 변경, 컴포넌트 on/off 등

CharacterController.Move(Vector3.zero)는
"캐릭터를 실제로 이동시키지 않지만",
"이동했다고 Unity가 간주해서" 충돌, 지면, 중력 계산을 다시 수행하게 만드는 함수 호출이다.

🎯 이 코드가 하는 일:
csharp
복사
편집
avatar.GetComponent<CharacterController>().Move(Vector3.zero);
캐릭터는 움직이지 않지만, Unity는 “움직였다고 착각”하게 만들어서
내부 충돌 시스템을 강제로 갱신하게 만드는 트릭이야.

✅ “이전 충돌 정보”가 문제였던 이유:
CharacterController는 enabled = true 될 때,
자기 몸이 지금 물리적으로 어디에 있는지 확인해서
콜라이더랑 겹치면 자동으로 충돌 반응을 일으킴.

그런데 위치를 transform.position = ...으로 바꿔도,
Unity는 물리 시스템에 “새 위치로 옮겼다”는 정보를 전달하지 않음.

그래서 Unity는 아직 캐릭터가 **이전 위치(켜지기 전 위치)**에 있다고 착각하고,
그 위치에서 콜라이더랑 겹쳐 있다고 판단함.

→ enabled = true 순간에 내부 충돌 처리 발생 → 튕김/끼임/움직이지 않음

✅ Move(Vector3.zero)는 뭘 해주냐:
이걸 호출하면 Unity는
“얘가 실제로 지금 위치에서 움직이려 했다”고 인식함.

그러면서 현재 위치 기준으로 충돌 상태를 재계산함.

→ 실제로는 겹쳐 있지 않다는 걸 이제야 알아챔.

→ 충돌 반응 취소됨 → 끼임 없음.

즉, 요약하면:

CharacterController를 껐다가 켜기만 하면 충돌 갱신이 안 돼서,
예전 위치 기준으로 충돌 오판이 생기고,
Move(Vector3.zero)는 그 충돌 정보를 정상화시킨다.

 그래서 겹친 이유는:
너 위치가 겹쳐 있었던 게 아니라,

Unity가 진짜 충돌 여부를 검사하지 않고 ‘아마 겹쳤겠지’라고 단정지어서
충돌 중인 것처럼 반응한 거다.

시간이 지나면서 Unity의 물리 엔진이 프레임을 거듭하며 CharacterController의 위치와 주변 Collider와의 관계를 재계산하고, 그제서야 실제로 겹쳐 있지 않다는 걸 인식하게 되기 때문이다.

// 위치 지정 후 Move(0)으로 물리 갱신 강제 실행
avatar.GetComponent<CharacterController>().Move(Vector3.zero);

Step Offset이란?
CharacterController가 계단이나 낮은 턱을 “자동으로 올라갈 수 있는 높이”를 지정하는 값이다.

📌 예를 들어:
csharp
복사
편집
CharacterController cc;
cc.stepOffset = 0.3f;
→ 캐릭터가 0.3미터 이하의 높이차를 만나면, 자동으로 부딪히지 않고 위로 올라감
→ 그 이상이면 부딪힘 처리됨

.Invoke()는 인스펙터에 등록된 모든 함수들을 순서대로 전부 실행시킨다.


public UnityEvent OnReplyReceived;
...
OnReplyReceived.Invoke();
